# 数据库面试题总结

# 概念相关

### 1. 请简述数据库中事务的特点、事务可能出现的问题？

* 特点（ACID）
  * **原子性（Atomicity）**：要么全部成功，要么全部失败回滚
  * **一致性(Consistency)**：不改变数据一致性
  * **隔离性(Isolation)**：并发的各个事务之间互不干扰
  * **持久性(Durability)**：被提交之后就是永久性的
* 可能出现的问题：
  * 脏读：读到了别的事务没有提交的事务
  * 不可重复读：同一个事务中，两次读到的数据不一致
  * 幻读：两次读的结果不一致（因为别的事务插入或者删除影响了自己读的结果）

### 2. 事务的隔离机制

* **read-uncommitted：**脏读、不可重复读、幻读都可能发生
* **read-committed(oracle默认)**：不会发生脏读，可能发生不可重复读、幻读。
* **repeatable read(Mysql默认):**所有被select获取的数据都不可能被修改，不会发生脏读、不可重复读，可能发生幻读。
* **serierlized**：两个事务完全独立，其中一个事务做的操作，对于另外一个事务不产生影响，都不会发生。

### 3. 数据库的范式

* 第一范式
  * 关系中的属性值都是不可分的原子值
* 第二范式
  * 不存在局部依赖，需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。
* 第三范式
  * 非主属性都不传递依赖R的候选键，每一列数据都和主键直接相关，而不能间接相关。

### 4. 触发器的作用？

* 触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。可以强化约束，来维护数据完整性和一致性。也可以联级运算。如，A表上的触发器包含对另B表的数据操作，而该操作又会导致A表触发器被触发。

### 5. 什么是存储过程？用什么来调用？

* 存储过程是一个**预编译的SQL语句**，优点是允许模块化设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个**命令对象**来调用存储过程。

### 6. 索引的作用？和它的优点缺点

* 索引就是一种特殊的查询表，数据库搜索引擎可以利用它对数据的检索。它很类似于现实生活中书的目录，不需要查询本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者多个列。
* 优点
  * 通过创建唯一索引，保证数据库中的数据的唯一性
  * 可以加快数据的检索速度，这也是创建索引的主要原因
  * 加快表与表之间的连接
* 缺点
  * 创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增加
  * 索引占用物理空间
  * 对表的数据进行增加、删除和修改的时候，索引也要动态的维护，这就降低了维护速度。
* 增加索引，提高检索性能，但会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。

### 7. 什么时候应该创建索引？什么时候不应该创建索引？

* 应该创建索引的列
  * 在经常搜索的列上，可以加快检索速度
  * 在主键的列上，强制该列的唯一性
  * 在经常连接的列上，使用外键
  * 在经常使用的where子句总的列上面创建索引，加快条件判断速度
* 不应该创建索引的情况
  * 对于那些查询很少使用或者参考的列
  * 对于那些很少数据值得列
  * 对于那些定义为text、image和bit数据类型的列
  * 当修改性能远远大于检索性能的时候，不应该创建索引。

### 8. 什么是事务？什么是锁？

* 事务
  * 事务就是绑定在一起作为一个逻辑工作单元的**SQL语句分组**。
  * 如果一个语句操作失败，以后操作就会回滚到操作前的状态。
* 锁
  * 在所有的DBMS中，锁是实现事务关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。

---------------------

# sql语句优化

##### 1. 使用explain关键字可以mysql是如何处理sql语句的，可以帮助我们分析性能瓶颈

##### 2.  当我们知道查询结果只有一行数据时，使用limit 1

##### 4. 避免select*，需要哪些字段就取哪些字段 

##### 5. 表关联尽量用主键，排序字段尽量使用主键 

##### 6. 当一个字段的值为固定选项时，应使用enum（内部是tinyint），不用vachar 

##### 7. 尽量使用preparedStatement可以防止sql注入 

##### 8. 尽量少用特别大的delete和insert语句，这两个操作会锁表 

##### 9. 任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的 

-----------------------------

# 实际应用

## 表操作相关

### 1. 表删除常用的几种方式？

- drop：drop删除非常粗暴，会将表以及表中的数据删除。
- truncate：删除表中的数据，并不删除对应的表的结构并且释放空间（清空表中的数据）。
- delete：删除表中的数据，删除数据的时候是一行一行的删除，并不删除对应的表的结构但是不释放空间（删除表中的数据）。
- 执行速度：drop》truncate》delete

### 2.左连接、右连接、内连接（A、B表）

- 左连接：A表中的所有数据以及B表中满足A表中信息的数据。
- 右连接：跟A左连接相反。
- 内连接：满足两个表中的数据
- select * from A Left JOIN B ON A.Aid=B.Bnameid

--------------

## 子查询

### 1.  from型子查询

* 将内层的查询结果供外层再次查询

* 使用场景：

* 查询挂科两门及其以上的同学的平均成绩

  * 思路：

    * 先查询出挂科两门的同学

      ```sql
      select name, count(*) as gk from student where score < 60 having gk >= 2
      ```

    * 查询出了对应的挂科两门以上的同学，我们需要取其中的姓名

      ```sql
      select name from (select name, count(*)  from student where score < 60 having gc >= 2) as t
      ```

    * 找出这些学生，在计算他们的平均分

      ```sql
      select name, avg(score) from student where name in (select name from (select name, count(*)  from student where score < 60 having gc >= 2) as t) group by name
      ```

### 2. where型子查询

* 把内层查询结果当作外层查询的比较条件

* 不是用order来查询最新的商品

  ```sql
  select goods_id,goods_name from goods where goods_id = (select max(goods_id) from goods);
  ```

* 取出每个栏目下最新的产品(goods_id唯一)

  ```sql
  select cat_id,goods_id,goods_name from goods where goods_id in(select max(goods_id) from goods group by cat_id);
  ```

### 3. exists型子查询

* 把外层查询结果拿到内层，看内层的查询是否成立

* 查询哪些栏目下有商品，栏目表category,商品表goods

  ```sql
  select cat_id,cat_name from category where exists(select * from goods where goods.cat_id = category.cat_id);
  ```

