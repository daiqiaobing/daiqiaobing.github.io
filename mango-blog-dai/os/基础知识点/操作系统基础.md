## 1. IO常用模型的介绍

### 1.1 常用的四种IO模型

* 同步阻塞IO(Blocking IO): 传统的IO模型
* 同步阻塞IO(Non-blocking IO):默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。
* IO多路复用(IO Multiplexing): 即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和linux中的epoll都是这种模型。
* 异步IO(AIO: Asynchronous IO):即经典的Proactor设计模式，也称为异步非阻塞IO。
* 同步与异步的区别：
  * 同步与异步描述的是用户线程与内核的交互方式
    * 同步：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行。
    * 异步：异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程。
* 阻塞与非阻塞的区别
  * 阻塞与非阻塞描述的是用户线程调用IO的方式
    * 阻塞是指IO操作需要彻底完成后才返回到用户空间
    * 非阻塞是指IO操作被调用后立即返回一份状态值，无需IO操作彻底完成。

### 1.2 同步阻塞IO

* 同步阻塞IO是最简单的IO模型，用户在内核中进行操作时候被阻塞，如下图琐事

  ![](../../../img/dai/java/BIO.png)

### 1.3 同步非阻塞IO

* 同步非阻塞IO是在同步阻塞IO的基础上。将socket设置为NONBLOCK。这样用户在发起IO请求的时候可以立即返回。

  ![](../../../img/dai/java/NIO.png)

### 1.4 IO多路复用

* IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。

* 用户首先将需要进行IO操作的socket添加到select中，然会阻塞等待select系统调用返回，当数据到达时，socket被激活。select函数返回。用户线程正式发起read请求，读取数据并执行。

  ![](../../../img/dai/java/多路复用.png)

### 1.5 异步IO

* 异步IO使用的是Proactor设计模式实现这一机制。

  ![](../../../img/dai/java/异步IO.png)